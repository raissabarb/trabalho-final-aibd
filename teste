def most_overdue_activity_per_course_and_num_students():
    today = datetime.today().strftime('%Y-%m-%d')
    course_activities = {}

    # Encontrar atividades atrasadas
    for activity_key in r.scan_iter('activity:*'):
        activity_details = r.hgetall(activity_key)
        due_date = activity_details.get(b'due_date', b'').decode('utf-8')
        course = activity_details.get(b'subject', b'').decode('utf-8')
        status = activity_details.get(b'status', b'').decode('utf-8')
        assigned_to = activity_details.get(b'assigned_to', b'').decode('utf-8')
        
        if due_date < today and status == 'not completed':
            if course not in course_activities:
                course_activities[course] = {}
            if (due_date, activity_key.decode('utf-8')) not in course_activities[course]:
                course_activities[course][(due_date, activity_key.decode('utf-8'))] = []
            course_activities[course][(due_date, activity_key.decode('utf-8'))].append(assigned_to)

    most_overdue_activities = {}
    for course, activities in course_activities.items():
        # Ordena as atividades pela data de vencimento
        sorted_activities = sorted(activities.keys(), key=lambda x: x[0])
        most_overdue_activity = sorted_activities[0]
        
        # Alunos atrasados na atividade mais atrasada
        overdue_students = activities[most_overdue_activity]
        
        most_overdue_activities[course] = {
            'activity': most_overdue_activity[1],
            'due_date': most_overdue_activity[0],
            'overdue_students': len(overdue_students),
            'students': overdue_students
        }

    return most_overdue_activities